<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>SVG Bracket Viewer</title>
    <style>
        html, body { height: 100%; width: 100%; }
        body {
            background: #0d0d0d;
            color: #eee;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            display: flex;
            overflow: hidden;
        }
        .container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }
        svg {
            width: 100%;
            height: 100%;
            background: #1a1a1a;
            border-radius: 16px;
            box-shadow: 0 0 30px rgba(0, 255, 128, 0.2);
        }
        text {
            fill: #ccc;
            font-size: 13px;
            dominant-baseline: middle;
            text-anchor: middle;
            pointer-events: none;
        }
        .line { stroke: #444; stroke-width: 2; }
        .line.winner-line { stroke: #22aa22; stroke-width: 3; filter: drop-shadow(0 0 3px #22aa22); }
        .winner { fill: #22aa22; font-weight: bold; filter: drop-shadow(0 0 4px #22aa22); }
        .final-winner { fill: #00ff88; font-weight: bold; filter: drop-shadow(0 0 4px #00ff88); }
        .box { fill: #252525; rx: 6; ry: 6; stroke: #333; stroke-width: 1; cursor: pointer; }
        select, input[type="file"] { margin-bottom: 20px; padding: 6px; font-size: 14px; }
        .sidebar {
            width: 220px;
            padding: 20px;
            background: #111;
            display: flex;
            flex-direction: column;
            gap: 10px;
            border-right: 1px solid #222;
            height: 100vh;
            overflow-y: auto;
            box-sizing: border-box;
        }
        .sidebar input[type="text"] { padding: 5px; background: #222; border: 1px solid #444; color: #eee; }
        .pending { fill: #ccc; }
        .default { fill: #aaa; }

        /* Confetti canvas (shown only while celebrating) */
        #confettiCanvas {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 9000;
            display: none;
        }

        /* Champion overlay */
        #championOverlay {
            position: fixed;
            inset: 0;
            display: none; /* shown on win */
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.6);
            z-index: 9999;
        }
        .champion-card {
            background: #121212;
            border: 1px solid #2a2a2a;
            border-radius: 16px;
            padding: 24px 32px;
            box-shadow: 0 0 40px rgba(0,255,128,0.25);
            text-align: center;
        }
        .champion-card h1 { margin: 0 0 8px; color: #00ff88; font-size: 24px; }
        .champion-card .name { color: #eee; font-weight: 700; font-size: 22px; letter-spacing: 0.5px; }
        .champion-card button {
            margin-top: 14px;
            padding: 8px 16px;
            border-radius: 10px;
            background: #00c271;
            color: #08130f;
            border: none;
            cursor: pointer;
        }
    </style>
</head>
<body>
<div class="sidebar">
    <label for="playerCount">Players</label>
    <select id="playerCount">
        <option value="2">2 Players</option>
        <option value="4" selected>4 Players</option>
        <option value="8">8 Players</option>
        <option value="16">16 Players</option>
        <option value="32">32 Players</option>
    </select>

    <label for="backgroundSelect">Background</label>
    <select id="backgroundSelect">
        <option value="dark" selected>Dark</option>
        <option value="light">Light</option>
        <option value="gradient">Gradient</option>
        <option value="upload">Upload Image</option>
    </select>

    <!-- Shown only for upload mode -->
    <input type="file" id="backgroundUpload" accept="image/*" style="display:none;" />

    <!-- Image position selector -->
    <label for="bgPosition" id="bgPositionLabel" style="display:none;">Image Position</label>
    <select id="bgPosition" style="display:none;">
        <option value="top" selected>Top</option>
        <option value="center">Center</option>
        <option value="bottom">Bottom</option>
    </select>

    <!-- Zoom controls -->
    <label for="zoomRange">Zoom</label>
    <input type="range" id="zoomRange" min="50" max="200" step="5" value="100" />
    <button id="zoomReset" type="button">Reset Zoom</button>

    <div id="nameInputs"></div>
</div>
<div class="container">
    <svg id="bracket" preserveAspectRatio="xMidYMid meet"><g id="zoomRoot"></g></svg>
</div>

<!-- Confetti layer -->
<canvas id="confettiCanvas" aria-hidden="true"></canvas>

<!-- Champion overlay -->
<div id="championOverlay" role="dialog" aria-modal="true" aria-labelledby="championTitle">
    <div class="champion-card">
        <h1 id="championTitle">Champion</h1>
        <div class="name" id="championName">UserX</div>
        <button id="closeChampion">Dismiss</button>
    </div>
</div>

<script>
    let totalPlayers = 4;
    const spacingY = 50;
    const boxW = 110;
    const boxH = 30;
    const roundSpacingX = 180;

    const svg = document.getElementById("bracket");
    const root = document.getElementById("zoomRoot");
    const select = document.getElementById("playerCount");
    const nameInputs = document.getElementById("nameInputs");
    const zoomRange = document.getElementById("zoomRange");
    const zoomReset = document.getElementById("zoomReset");
    let zoom = 1;
    function applyZoom(){
        // uniform scale around SVG origin; simple and safe
        root.setAttribute('transform', `scale(${zoom})`);
    }
    if (zoomRange) {
        zoomRange.addEventListener('input', () => {
            const v = parseInt(zoomRange.value, 10) / 100;
            zoom = Math.min(2, Math.max(0.5, v));
            applyZoom();
        });
    }
    if (zoomReset) {
        zoomReset.addEventListener('click', () => { zoom = 1; if (zoomRange) zoomRange.value = 100; applyZoom(); });
    }
    // ctrl+wheel for quick zoom (doesn't interfere with normal scroll)
    svg.addEventListener('wheel', (e) => {
        if (!e.ctrlKey) return; // only when pinching or ctrl+wheel
        e.preventDefault();
        const f = e.deltaY < 0 ? 1.1 : 0.9;
        zoom = Math.min(2, Math.max(0.5, zoom * f));
        if (zoomRange) zoomRange.value = Math.round(zoom * 100);
        applyZoom();
    }, { passive: false });
    applyZoom();
    const bgSelect = document.getElementById("backgroundSelect");
    const bgUpload = document.getElementById("backgroundUpload");
    const bgPosition = document.getElementById("bgPosition");
    const bgPositionLabel = document.getElementById("bgPositionLabel");

    const championOverlay = document.getElementById('championOverlay');
    const championNameEl = document.getElementById('championName');
    const closeChampionBtn = document.getElementById('closeChampion');

    // Confetti
    const confettiCanvas = document.getElementById('confettiCanvas');
    const ctx = confettiCanvas.getContext('2d');
    let confettiActive = false;
    let confettiRAF = null;
    let particles = [];

    let winners = {};
    let playerNames = [];
    let lastChampionName = null; // to avoid retriggering

    function updateNameInputs() {
        nameInputs.innerHTML = "";
        playerNames = [];
        for (let i = 0; i < totalPlayers; i++) {
            const input = document.createElement("input");
            input.type = "text";
            input.placeholder = `User${i + 1}`;
            input.value = `User${i + 1}`;
            input.addEventListener("input", () => renderBracket());
            nameInputs.appendChild(input);
            playerNames.push(input);
        }
    }

    // ---- Background helpers ----
    function setBgVisibleForUploadMode(isUpload) {
        bgUpload.style.display = isUpload ? 'block' : 'none';
        bgPosition.style.display = isUpload ? 'block' : 'none';
        bgPositionLabel.style.display = isUpload ? 'block' : 'none';
    }

    function applyBgPosition() {
        const pos = bgPosition.value;
        const map = {
            top: 'top center',
            center: 'center center',
            bottom: 'bottom center'
        };
        document.body.style.backgroundPosition = map[pos] || 'center center';
    }

    // Background switching (supports both 'upload' and 'bgimage' just in case)
    bgSelect.addEventListener("change", () => {
        switch (bgSelect.value) {
            case "dark":
                document.body.style.background = "#0d0d0d";
                document.body.style.backgroundSize = '';
                document.body.style.backgroundPosition = '';
                svg.style.background = "#1a1a1a";
                setBgVisibleForUploadMode(false);
                break;
            case "light":
                document.body.style.background = "#f0f0f0";
                document.body.style.backgroundSize = '';
                document.body.style.backgroundPosition = '';
                svg.style.background = "#fff";
                setBgVisibleForUploadMode(false);
                break;
            case "gradient":
                document.body.style.background = "linear-gradient(135deg, #0f2027, #203a43, #2c5364)";
                document.body.style.backgroundSize = '';
                document.body.style.backgroundPosition = '';
                svg.style.background = "rgba(0,0,0,0.6)";
                setBgVisibleForUploadMode(false);
                break;
            case "upload":
            case "bgimage":
                setBgVisibleForUploadMode(true);
                applyBgPosition();
                break;
        }
    });

    bgUpload?.addEventListener("change", (event) => {
        const file = event.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                document.body.style.background = `url('${e.target.result}') no-repeat center center fixed`;
                document.body.style.backgroundSize = "cover";
                applyBgPosition();
                svg.style.background = "rgba(0,0,0,0.7)";
            };
            reader.readAsDataURL(file);
        }
    });

    bgPosition.addEventListener('change', applyBgPosition);

    function drawBoxedText(x, yCenter, name, key, round, index, parentKey) {
        const y = yCenter - boxH / 2;
        const group = document.createElementNS("http://www.w3.org/2000/svg", "g");

        const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        rect.setAttribute("x", x);
        rect.setAttribute("y", y);
        rect.setAttribute("width", boxW);
        rect.setAttribute("height", boxH);
        rect.setAttribute("class", "box");

        if (name) {
            rect.addEventListener("click", () => {
                if (parentKey && winners[parentKey] && winners[parentKey] !== name) return;
                if (winners[parentKey] === name) {
                    delete winners[parentKey];
                } else {
                    winners[parentKey] = name;
                }
                renderBracket();
            });
        }

        group.appendChild(rect);

        const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
        text.setAttribute("x", x + boxW / 2);
        text.setAttribute("y", y + boxH / 2);

        const isCurrentWinner = winners[parentKey] === name;
        const isMatchResolved = !!winners[key];
        const isFeederWinner = parentKey && winners[parentKey] === name && !isMatchResolved;
        const rounds = Math.log2(totalPlayers);
        const finalKey = `${rounds}-0`;
        if (winners[finalKey]) {
            text.setAttribute("class", "winner");
        }
        else if (isCurrentWinner && isMatchResolved) {
            text.setAttribute("class", "winner");
        } else if (isFeederWinner) {
            text.setAttribute("class", "winner");
        } else if (name) {
            text.setAttribute("class", "default");
        }

        text.textContent = name;
        group.appendChild(text);
        root.appendChild(group);
        return y + boxH / 2;
    }

    function drawLine(x1, y1, x2, y2, isWinnerLine = false) {
        const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
        line.setAttribute("x1", x1);
        line.setAttribute("y1", y1);
        line.setAttribute("x2", x2);
        line.setAttribute("y2", y2);
        line.setAttribute("class", isWinnerLine ? "line winner-line" : "line");
        root.appendChild(line);
    }

    function renderBracket() {
        root.innerHTML = "";
        const rounds = Math.log2(totalPlayers);
        const yCoords = {};

        for (let r = 0; r <= rounds; r++) {
            const matches = totalPlayers / Math.pow(2, r);
            for (let i = 0; i < matches; i++) {
                const x = 40 + r * roundSpacingX;
                let yCenter = 80 + i * spacingY * Math.pow(2, r);

                const key = `${r}-${i}`;
                let name = "";

                if (r === 0) {
                    name = playerNames[i]?.value || `User${i + 1}`;
                    yCoords[key] = drawBoxedText(x, yCenter, name, key, r, i, `${r + 1}-${Math.floor(i / 2)}`);
                } else {
                    const prevKey1 = `${r - 1}-${i * 2}`;
                    const prevKey2 = `${r - 1}-${i * 2 + 1}`;
                    const winner1 = winners[prevKey1];
                    const winner2 = winners[prevKey2];

                    const y1 = yCoords[prevKey1];
                    const y2 = yCoords[prevKey2];
                    const bothExist = y1 !== undefined && y2 !== undefined;
                    const yMid = bothExist ? (y1 + y2) / 2 : y1 ?? y2;

                    yCoords[key] = drawBoxedText(x, yMid, winners[key] || "", key, r, i);

                    if (winner1) drawBoxedText(x - roundSpacingX, y1, winner1, prevKey1, r - 1, i * 2, key);
                    if (winner2) drawBoxedText(x - roundSpacingX, y2, winner2, prevKey2, r - 1, i * 2 + 1, key);

                    const highlight1 = winner1 && winners[key] === winner1;
                    const highlight2 = winner2 && winners[key] === winner2;

                    if (y1 !== undefined) drawLine(x - roundSpacingX + boxW, y1, x - 10, y1, highlight1);
                    if (y2 !== undefined) drawLine(x - roundSpacingX + boxW, y2, x - 10, y2, highlight2);
                    if (bothExist) drawLine(x - 10, y1, x - 10, y2, highlight1 || highlight2);
                    drawLine(x - 10, yMid, x, yMid, (highlight1 || highlight2));
                }
            }
        }

        // ===== Final-winner detection & celebration =====
        const finalKey = `${rounds}-0`;
        const champ = winners[finalKey];
        if (champ && champ !== lastChampionName) {
            lastChampionName = champ;
            showChampionOverlay(champ);
        } else if (!champ) {
            // reset state if bracket cleared/changed
            lastChampionName = null;
            hideChampionOverlay();
        }
    }

    select.addEventListener("change", () => {
        totalPlayers = parseInt(select.value);
        winners = {};
        lastChampionName = null;
        hideChampionOverlay();
        updateNameInputs();
        renderBracket();
    });

    // Champion overlay
    function showChampionOverlay(name) {
        championNameEl.textContent = name || 'Unknown';
        championOverlay.style.display = 'flex';
        if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
            startConfetti(6500);
        }
    }
    function hideChampionOverlay() {
        championOverlay.style.display = 'none';
        stopConfetti();
    }
    closeChampionBtn.addEventListener('click', hideChampionOverlay);
    championOverlay.addEventListener('click', (e) => {
        if (e.target === championOverlay) hideChampionOverlay();
    });
    window.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') hideChampionOverlay();
    });

    // ---- Confetti implementation ----
    function resizeConfettiCanvas() {
        const dpr = Math.max(1, window.devicePixelRatio || 1);
        confettiCanvas.width = Math.floor(window.innerWidth * dpr);
        confettiCanvas.height = Math.floor(window.innerHeight * dpr);
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // draw in CSS pixels
    }

    function startConfetti(durationMs = 6000) {
        resizeConfettiCanvas();
        particles = createParticles();
        confettiCanvas.style.display = 'block';
        confettiActive = true;
        const start = performance.now();
        function frame(now) {
            if (!confettiActive) return;
            const t = now - start;
            drawParticles(t / durationMs);
            if (t < durationMs) {
                confettiRAF = requestAnimationFrame(frame);
            } else {
                stopConfetti();
            }
        }
        confettiRAF = requestAnimationFrame(frame);
    }

    function stopConfetti() {
        confettiActive = false;
        if (confettiRAF) cancelAnimationFrame(confettiRAF);
        confettiRAF = null;
        confettiCanvas.style.display = 'none';
        ctx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
    }

    function createParticles() {
        const w = window.innerWidth;
        const h = window.innerHeight;
        const area = w * h;
        const base = Math.min(280, Math.max(80, Math.floor(area / 18000)));
        const colors = ['#00ff88', '#22aa22', '#b4ffd9', '#ffffff'];
        const arr = [];
        for (let i = 0; i < base; i++) {
            arr.push({
                x: Math.random() * w,
                y: -20 - Math.random() * h, // start above screen
                vx: (Math.random() - 0.5) * 0.8,
                vy: 1.2 + Math.random() * 2.2,
                size: 2 + Math.random() * 4,
                rot: Math.random() * Math.PI,
                vr: (Math.random() - 0.5) * 0.2,
                color: colors[(Math.random() * colors.length) | 0],
                alpha: 0.9
            });
        }
        return arr;
    }

    function drawParticles(progress) {
        const w = window.innerWidth;
        const h = window.innerHeight;
        ctx.clearRect(0, 0, w, h);
        ctx.save();
        ctx.shadowBlur = 8;
        ctx.shadowColor = 'rgba(0,255,136,0.6)';
        for (const p of particles) {
            p.x += p.vx;
            p.y += p.vy;
            p.rot += p.vr;
            // fade out near the end
            if (progress > 0.75) p.alpha = Math.max(0, 1 - (progress - 0.75) * 4);
            if (p.y > h + 10) {
                p.y = -10; p.x = Math.random() * w; // recycle
            }
            ctx.globalAlpha = p.alpha;
            ctx.translate(p.x, p.y);
            ctx.rotate(p.rot);
            ctx.fillStyle = p.color;
            ctx.fillRect(-p.size * 0.5, -p.size * 0.5, p.size, p.size * 1.6);
            ctx.setTransform(1, 0, 0, 1, 0, 0);
        }
        ctx.restore();
    }

    window.addEventListener('resize', () => {
        if (confettiActive) resizeConfettiCanvas();
    });

    updateNameInputs();
    renderBracket();
</script>
</body>
</html>
